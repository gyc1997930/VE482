Before I did my homework, I was not so familiar with how semaphore works. So I searched the Internet and found a very interesting illustration. It makes an analogy between semaphore and restroom. Imagine there are totally 10 restrooms and 12 people waiting to use them. The semaphore acts like restroom manager. He first gives one key to one person so that the total available key numbers will decrease by 1. When the customer finishes using the restroom and returns the key to the manager, he adds 1 to the key number. That's basically how semaphore works.
First, I declare a global variable sem, which is a pointer to sem_t. In the thread_count function, I first used sem_wait to decrease the available key number by 1. When the operation is done, I then used sem_post to add 1 to the key number.
Then, in the main function, I used sem_init to initialize the semaphore. Besides the sem variable itself, there are two parameters in this function, namely shared and value. pshared is set to 0 to indicate that the signal is shared by all the threads in the current process. Value gives the initial value of the signal. Or you can just imagine value defines how many restrooms there are in our case.
I stored that return value in a variable res. When that variable is not 0, it means that our initialization fails.
In the end of main function, I used sem_destroy to destroy the semaphore.
